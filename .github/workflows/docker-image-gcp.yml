name: Publish Docker image (GCP Artifact Registry)

on:
  workflow_dispatch:
  push:
    tags:
      - '*'

# Global configuration for GCP
env:
  # CHANGE THESE TO MATCH YOUR GCP SETUP
  GCP_REGION: asia-southeast1
  GCP_PROJECT: project-7980c6e7-14f0-4ff0-ac9/new-api
  GCP_REPO_NAME: new-api
  IMAGE_NAME: new-api
  # This constructs the base path: asia-southeast1-docker.pkg.dev/project/repo/image
  GCP_REGISTRY_HOST: asia-southeast1-docker.pkg.dev
  FULL_IMAGE_PATH: asia-southeast1-docker.pkg.dev/project-7980c6e7-14f0-4ff0-ac9/new-api/new-api

jobs:
  build_single_arch:
    name: Build & push (${{ matrix.arch }}) [native]
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            platform: linux/amd64
            runner: ubuntu-latest
          - arch: arm64
            platform: linux/arm64
            runner: ubuntu-24.04-arm
    runs-on: ${{ matrix.runner }}

    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Check out (shallow)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Resolve tag & generate tag list
        run: |
          # ... (Your existing fetch logic) ...
          git fetch --tags --force --depth=1
        
          # 1. Define Timestamp and Base TAG
          TS=$(date +%Y%m%d-%H%M%S)
          
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            # Is a Tag -> Use tag name
            TAG=${GITHUB_REF#refs/tags/}
            IS_RELEASE=true
          else
            # Is a Branch -> Use branch-timestamp
            TAG=${GITHUB_REF#refs/heads/}
            TAG=${TAG//\//-}
            TAG="${TAG}-${TS}"
            IS_RELEASE=false
          fi

          # 2. Construct the list of docker tags
          # Start with the specific version tag (Always needed)
          # Note: $FULL_IMAGE_PATH must be available in your job env
          TAG_LIST="${{ env.FULL_IMAGE_PATH }}:${TAG}-${{ matrix.arch }}"
        
          # Only append 'latest' if this is a real Release Tag
          if [ "$IS_RELEASE" = true ]; then
            TAG_LIST="${TAG_LIST},${FULL_IMAGE_PATH}:latest-${{ matrix.arch }}"
          fi
          
          # 3. Output variables
          echo "TAG=$TAG" >> $GITHUB_ENV
          echo "DOCKER_TAGS=$TAG_LIST" >> $GITHUB_ENV

          echo "Tags to build: $TAG_LIST"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Authenticate to Google Cloud
        id: auth
        uses: 'google-github-actions/auth@v2'
        with:
          token_format: 'access_token'
          # You create this "provider" once in GCP Console
          workload_identity_provider: 'projects/865218081826/locations/global/workloadIdentityPools/new-api-ruipliu/providers/github'
          service_account: 'new-api-service-acc@project-7980c6e7-14f0-4ff0-ac9.iam.gserviceaccount.com'

      - name: Log in to GCP Artifact Registry
        uses: docker/login-action@v3
        with:
          registry: asia-southeast1-docker.pkg.dev
          username: 'oauth2accesstoken'
          password: ${{ steps.auth.outputs.access_token }}

      - name: Extract metadata (labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.FULL_IMAGE_PATH }}

      # --- CHANGED: Push to GCP Paths ---
      - name: Build & push single-arch
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: ${{ matrix.platform }}
          push: true
          # Use the dynamic list we created in the previous step
          tags: ${{ env.DOCKER_TAGS }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false
          sbom: false

  create_manifests:
    name: Create multi-arch manifests (GCP)
    needs: [build_single_arch]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Extract tag
        run: echo "TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV

      # --- CHANGED: Login to GCP (Required for manifest creation too) ---
      - name: Log in to GCP Artifact Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GCP_REGISTRY_HOST }}
          username: _json_key
          password: ${{ secrets.GCP_SA_KEY }}

      # --- CHANGED: Point manifest creation to GCP images ---
      - name: Create & push manifest (GCP - version)
        run: |
          docker buildx imagetools create \
            -t ${{ env.FULL_IMAGE_PATH }}:${TAG} \
            ${{ env.FULL_IMAGE_PATH }}:${TAG}-amd64 \
            ${{ env.FULL_IMAGE_PATH }}:${TAG}-arm64

      - name: Create & push manifest (GCP - latest)
        run: |
          docker buildx imagetools create \
            -t ${{ env.FULL_IMAGE_PATH }}:latest \
            ${{ env.FULL_IMAGE_PATH }}:latest-amd64 \
            ${{ env.FULL_IMAGE_PATH }}:latest-arm64
  deploy:
    name: Deploy to Cloud Run
    needs: [ build_single_arch ] # Wait for build to finish
    environment: prod
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
    permissions:
      id-token: write

    steps:
      - name: Authenticate to Google Cloud
        id: auth
        uses: 'google-github-actions/auth@v2'
        with:
          token_format: 'access_token'
          workload_identity_provider: 'projects/865218081826/locations/global/workloadIdentityPools/new-api-ruipliu/providers/github'
          service_account: 'new-api-service-acc@project-7980c6e7-14f0-4ff0-ac9.iam.gserviceaccount.com'

      - name: Deploy to Cloud Run
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'new-api'
          region: 'asia-southeast1'
          # Use the TAG established in the previous job.
          # Note: You'll need to pass the TAG as an output from the build job
          # OR use the same logic to re-calculate it here.
          image: ${{ env.FULL_IMAGE_PATH }}:${{ env.TAG }}-amd64
          flags: '--allow-unauthenticated'
